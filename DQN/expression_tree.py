


class Node:
    '''
    The Node class represents a node in the expression tree. It defines the nodes name, arity, children, and mathematical operation.
    Specific node classes inherit from this to define their own operations
    '''
    def __init__(self, name, arity):
        self.left_child = None
        self.right_child = None
        self.name = named
        self.arity = arity
        

class ExpressionTree():
	'''
	The ExpressionTree class is used to instantiate symbolic equation objects. These objects act as states in the first MDP. 
	'''

	def __init__(self, tree_depth):
        '''
        - Considering an complete binary tree (one where all non-terminal nodes have exactly 2 children) of empty nodes as the initial state. This 
        avoids restricting the scope of the expressions that can be generated. 

        - The initial state is set to have a 'plus' root node and 'zero' left node to ensure consistency across episodes. These operators
        of course have no effect on the final expression generated by the policy, but act as a standardised starting state for all episodes

        - One of the agent's possible actions is to also add a terminal zero_node. The policy can hence also be directed towards 
        generating any binary tree (one where nodes can have any of {0,1,2} children)
        
        - Note: pre-order traversals are generally not unique. However, they can be if the arity of a node is known (which is the case here)
        
        - New nodes are added in the empty spots as per the pre-order traversal order
        
        - Subtracting nodes is not an option since, in the context of sequential decision making, it's existence has no effect on learning. The
        agent will simply learn to add a different operator (or add nothing) at a given spot if the current addition produces poor rewards
        '''
        self.tree_depth = tree_depth # depth of the tree including the root level
        self.tree_full = False
        plus_node = Node('plus', 2)
        zero_node = None('const', 0)
        plus_node.left_child = zero_node
		self.preorder_trav = [None for _ in range(2**tree_depth - 1)] 
        preorder_trav[0] = plus_node
        preorder_trav[1] = zero_node


	def update(self, action):
		# Update the pre-order traversal with the performed action (addition of an operator)
        self.preorder_trav = new_preorder_trav
        if all_possible_tree_nodes_occupied:
            self.tree_full = True
        return self.vectorise_preorder_trav(self.preorder_trav), self.tree_full

	def evaluate(self, main_env_state):
		# Evaluate the current symbolic eq with the main_env's state to get action values for the main_env

    def vectorise_preorder_trav(self):
        # Turn the preorder traversal of the tree (list of nodes that are operator tokens) into a vector representation
